\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}

\begin{document}
	\begin{center}	
		Алгоритмы и структуры данных. \\
		Семинар 7 \\
		Григорьев Дмитрий БПМИ-163\\
	\end{center}
	\textbf{Задача 1.} \\
	Посмотрим сколько раз изменяется каждый бит "длинного" числа $n$.
	Первый бит изменится ровно $n$ раз. Второй бит изменится $\frac{n}{2}$ раз, так как второй бит будет изменяться после полного  всех перестановок длины 1, а их всего $2^1 = 2$, третий бит изменится $\frac{n}{4}$ раз, так как перед этим битом есть последовательность длины 2, т. е. бит будет изменяться каждые 4 инкримента. Итак, получается, что бит, стоящий в позиции $l$, будет меняться $\frac{n}{2^{l}}$ раз.\\
	После $n$ инкрементов будет выполнено $n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + ...$ раз. Эта последовательность стремится к $2n$. Получается что фактическая стоимость последовательных операций инкремента длинного двоичного числа это  $\mathcal{O}(n)$. \\
	
	\noindent
	\textbf{Задача 2.} \\
	
	\noindent
	$Node* last = list.begin()\\
	Node* next = last->next\\
	Node* tmp\\
	last->next = NULL;\\
	while(next != NULL) \\
	\indent tmp = next->next\\
	\indent	next->next = last\\
	\indent	last = next\\
	\indent	next = tmp\\
	$	\\
	\noindent
	\textbf{Задача 3.} \\
	Пусть существует такая шаблонная структура данных с операциями вставки, поиска и удаления минимума за $\mathcal{O}(1)$. Мы добавим в нее все элементы за $n \cdot \mathcal{O}(1) = \mathcal{O}(n)$. Мы можем удалять и искать минимум за $\mathcal{O}(1)$. Тогда мы можем отсортировать элементы за $\mathcal{O}(n)$, найдя минимум запомнить его и удалить. \\
	Но мы знаем, что по Теореме о нижней оценке для сортировки сравнениями: в худшем случае любой алгоритм сортировки сравнениями выполняет $\Omega(n \log n)$ сравнений, где n — число сортируемых элементов. \\
	Получается противоречие в том, что наша структура может отсортировать n элементов за $\mathcal{O}(n)$. Значит такой структуры не существует.
	\begin{flushright}	
		ч.т.д.
	\end{flushright}
	\newpage
	\noindent
	\textbf{Задача 4.} \\
	Пусть существует такая шаблонная структура данных с операциями вставки, поиска медианы за  $\mathcal{O}(1)$. Мы добавим в нее все элементы за $n \cdot \mathcal{O}(1) = \mathcal{O}(n)$. Мы можем искать медиану за $\mathcal{O}(1)$. Тогда мы можем отсортировать элементы за $\mathcal{O}(n)$ следующим образом: \\
	Будем вставлять две $-\infty$ и каждый раз искать и запоминать новую медиану до тех пор пока новая медиана не будет равна $-\infty$. Так мы упорядочим элементы, меньшие первоночальной медианы. Теперь надо вставлять по 2 $+\infty$ столько же раз, сколько мы вставляли $-\infty$. И далее нужно опять вставлять по 2 $+\infty$ и каждый раз искать и запоминать  медиану до тех пор пока медиана не будет равна $+\infty$. \\
	Таким образом мы получим отсортированный массив за $\mathcal{O}(n)$. \\
	Получается противоречие в том, что наша структура может отсортировать n элементов за $\mathcal{O}(n)$. Значит такой структуры не существует.
	\begin{flushright}	
		ч.т.д.
	\end{flushright} 
	
\end{document}
